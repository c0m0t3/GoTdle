/* tslint:disable */
/* eslint-disable */
/**
 * openAPI_GoTdle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Characters
 */
export interface Characters {
    /**
     * 
     * @type {number}
     * @memberof Characters
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'gender': string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'born'?: string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'origin': string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'death'?: string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'culture'?: string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'religion': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Characters
     */
    'titles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'house': string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'father'?: string;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'mother'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Characters
     */
    'spouse'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Characters
     */
    'children'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Characters
     */
    'siblings'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Characters
     */
    'lovers'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Characters
     */
    'seasons': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Characters
     */
    'actor'?: string;
}
/**
 * 
 * @export
 * @interface PostUserLogin200Response
 */
export interface PostUserLogin200Response {
    /**
     * 
     * @type {string}
     * @memberof PostUserLogin200Response
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface PostUserLoginRequest
 */
export interface PostUserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof PostUserLoginRequest
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserLoginRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserLoginRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface PostUserRegister201Response
 */
export interface PostUserRegister201Response {
    /**
     * 
     * @type {PostUserRegister201ResponseUser}
     * @memberof PostUserRegister201Response
     */
    'user'?: PostUserRegister201ResponseUser;
}
/**
 * 
 * @export
 * @interface PostUserRegister201ResponseUser
 */
export interface PostUserRegister201ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof PostUserRegister201ResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRegister201ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRegister201ResponseUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRegister201ResponseUser
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface PostUserRegisterRequest
 */
export interface PostUserRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof PostUserRegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRegisterRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PutUserByIdRequest
 */
export interface PutUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof PutUserByIdRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutUserByIdRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutUserByIdRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface Scores
 */
export interface Scores {
    /**
     * Erstellungsdatum des Accounts
     * @type {string}
     * @memberof Scores
     */
    'lastPlayed'?: string;
    /**
     * deafult 0  
     * @type {number}
     * @memberof Scores
     */
    'Streak'?: number;
    /**
     * deafult 0
     * @type {number}
     * @memberof Scores
     */
    'LongestStreak'?: number;
    /**
     * deafult 0
     * @type {Array<number>}
     * @memberof Scores
     */
    'dailyScore'?: Array<number>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the given user.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * The date that the user was created.
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Scores}
     * @memberof User
     */
    'scores'?: Scores;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get character for classic mode
         * @summary Get Character Info by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCharacterById', 'id', id)
            const localVarPath = `/characters/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all characters to use its name for the Answer-SelectControl-Options
         * @summary Get All Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/characters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * for searching a specific user in scoreboard
         * @summary Get User Info by Username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/users/name/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users for Scoreboard
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login user with email or username.   If successfully logged in, the user receives an access token in return.
         * @summary Login User
         * @param {PostUserLoginRequest} [postUserLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin: async (postUserLoginRequest?: PostUserLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postUserLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user through Registration
         * @summary Create New User
         * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserRegister: async (postUserRegisterRequest?: PostUserRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postUserRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Score by User ID
         * @param {string} userId 
         * @param {Scores} [scores] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScoresByUserId: async (userId: string, scores?: Scores, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putScoresByUserId', 'userId', userId)
            const localVarPath = `/scores/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scores, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} id 
         * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserById: async (id: string, putUserByIdRequest?: PutUserByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putUserByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get character for classic mode
         * @summary Get Character Info by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Characters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacterById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCharacterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all characters to use its name for the Answer-SelectControl-Options
         * @summary Get All Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Characters>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCharacters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * for searching a specific user in scoreboard
         * @summary Get User Info by Username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users for Scoreboard
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login user with email or username.   If successfully logged in, the user receives an access token in return.
         * @summary Login User
         * @param {PostUserLoginRequest} [postUserLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserLogin(postUserLoginRequest?: PostUserLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUserLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserLogin(postUserLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postUserLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user through Registration
         * @summary Create New User
         * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserRegister(postUserRegisterRequest?: PostUserRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUserRegister201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserRegister(postUserRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postUserRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Score by User ID
         * @param {string} userId 
         * @param {Scores} [scores] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScoresByUserId(userId: string, scores?: Scores, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scores>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScoresByUserId(userId, scores, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putScoresByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} id 
         * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserById(id: string, putUserByIdRequest?: PutUserByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserById(id, putUserByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get character for classic mode
         * @summary Get Character Info by Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Characters> {
            return localVarFp.getCharacterById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all characters to use its name for the Answer-SelectControl-Options
         * @summary Get All Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacters(options?: RawAxiosRequestConfig): AxiosPromise<Array<Characters>> {
            return localVarFp.getCharacters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * for searching a specific user in scoreboard
         * @summary Get User Info by Username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users for Scoreboard
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Login user with email or username.   If successfully logged in, the user receives an access token in return.
         * @summary Login User
         * @param {PostUserLoginRequest} [postUserLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin(postUserLoginRequest?: PostUserLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostUserLogin200Response> {
            return localVarFp.postUserLogin(postUserLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user through Registration
         * @summary Create New User
         * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserRegister(postUserRegisterRequest?: PostUserRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostUserRegister201Response> {
            return localVarFp.postUserRegister(postUserRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Score by User ID
         * @param {string} userId 
         * @param {Scores} [scores] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScoresByUserId(userId: string, scores?: Scores, options?: RawAxiosRequestConfig): AxiosPromise<Scores> {
            return localVarFp.putScoresByUserId(userId, scores, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} id 
         * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserById(id: string, putUserByIdRequest?: PutUserByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.putUserById(id, putUserByIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Delete User by User ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUserById(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get character for classic mode
     * @summary Get Character Info by Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCharacterById(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCharacterById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all characters to use its name for the Answer-SelectControl-Options
     * @summary Get All Characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCharacters(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCharacters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Info by User ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserById(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * for searching a specific user in scoreboard
     * @summary Get User Info by Username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserByUsername(username: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users for Scoreboard
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login user with email or username.   If successfully logged in, the user receives an access token in return.
     * @summary Login User
     * @param {PostUserLoginRequest} [postUserLoginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postUserLogin(postUserLoginRequest?: PostUserLoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postUserLogin(postUserLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user through Registration
     * @summary Create New User
     * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postUserRegister(postUserRegisterRequest?: PostUserRegisterRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postUserRegister(postUserRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Score by User ID
     * @param {string} userId 
     * @param {Scores} [scores] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putScoresByUserId(userId: string, scores?: Scores, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putScoresByUserId(userId, scores, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User by User ID
     * @param {string} id 
     * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putUserById(id: string, putUserByIdRequest?: PutUserByIdRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putUserById(id, putUserByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



