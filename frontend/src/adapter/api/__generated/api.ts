/* tslint:disable */
/* eslint-disable */
/**
 * openAPI_GoTdle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface Characters
 */
export interface Characters {
  /**
   *
   * @type {number}
   * @memberof Characters
   */
  _id: number;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  gender: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  born: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  origin: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  death: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  culture: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  religion: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Characters
   */
  titles: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  house: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  father: string;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  mother: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Characters
   */
  spouse: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Characters
   */
  children: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Characters
   */
  siblings: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Characters
   */
  lovers: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof Characters
   */
  seasons: Array<number>;
  /**
   *
   * @type {string}
   * @memberof Characters
   */
  actor: string;
}
/**
 *
 * @export
 * @interface DeleteUserByIdRequest
 */
export interface DeleteUserByIdRequest {
  /**
   *
   * @type {string}
   * @memberof DeleteUserByIdRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface PostUserLogin200Response
 */
export interface PostUserLogin200Response {
  /**
   *
   * @type {string}
   * @memberof PostUserLogin200Response
   */
  accessToken?: string;
}
/**
 *
 * @export
 * @interface PostUserLoginRequest
 */
export interface PostUserLoginRequest {
  /**
   *
   * @type {string}
   * @memberof PostUserLoginRequest
   */
  identifier: string;
  /**
   *
   * @type {string}
   * @memberof PostUserLoginRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof PostUserLoginRequest
   */
  type: string;
}
/**
 *
 * @export
 * @interface PostUserRegister201Response
 */
export interface PostUserRegister201Response {
  /**
   *
   * @type {PostUserRegister201ResponseUser}
   * @memberof PostUserRegister201Response
   */
  user?: PostUserRegister201ResponseUser;
}
/**
 *
 * @export
 * @interface PostUserRegister201ResponseUser
 */
export interface PostUserRegister201ResponseUser {
  /**
   *
   * @type {string}
   * @memberof PostUserRegister201ResponseUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PostUserRegister201ResponseUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PostUserRegister201ResponseUser
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof PostUserRegister201ResponseUser
   */
  createdAt?: string;
}
/**
 *
 * @export
 * @interface PostUserRegister400Response
 */
export interface PostUserRegister400Response {
  /**
   *
   * @type {Array<string>}
   * @memberof PostUserRegister400Response
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface PostUserRegisterRequest
 */
export interface PostUserRegisterRequest {
  /**
   *
   * @type {string}
   * @memberof PostUserRegisterRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof PostUserRegisterRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof PostUserRegisterRequest
   */
  username: string;
}
/**
 *
 * @export
 * @interface PutScoreByUserId200Response
 */
export interface PutScoreByUserId200Response {
  /**
   *
   * @type {string}
   * @memberof PutScoreByUserId200Response
   */
  userId?: string;
  /**
   *
   * @type {number}
   * @memberof PutScoreByUserId200Response
   */
  streak?: number;
  /**
   *
   * @type {string}
   * @memberof PutScoreByUserId200Response
   */
  lastPlayed?: string;
  /**
   *
   * @type {number}
   * @memberof PutScoreByUserId200Response
   */
  longestStreak?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof PutScoreByUserId200Response
   */
  dailyScore?: Array<number>;
}
/**
 *
 * @export
 * @interface PutScoreByUserIdRequest
 */
export interface PutScoreByUserIdRequest {
  /**
   *
   * @type {string}
   * @memberof PutScoreByUserIdRequest
   */
  streak: string;
  /**
   *
   * @type {string}
   * @memberof PutScoreByUserIdRequest
   */
  longestStreak?: string;
  /**
   *
   * @type {Array<number>}
   * @memberof PutScoreByUserIdRequest
   */
  dailyScore: Array<number>;
}
/**
 *
 * @export
 * @interface PutUserByIdRequest
 */
export interface PutUserByIdRequest {
  /**
   *
   * @type {string}
   * @memberof PutUserByIdRequest
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof PutUserByIdRequest
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PutUserByIdRequest
   */
  password?: string;
}
/**
 *
 * @export
 * @interface Scores
 */
export interface Scores {
  /**
   * deafult 0
   * @type {number}
   * @memberof Scores
   */
  streak: number;
  /**
   * Erstellungsdatum des Accounts
   * @type {string}
   * @memberof Scores
   */
  lastPlayed: string;
  /**
   * deafult 0
   * @type {number}
   * @memberof Scores
   */
  longestStreak: number;
  /**
   * deafult 0
   * @type {Array<number>}
   * @memberof Scores
   */
  dailyScore: Array<number>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * Unique identifier for the given user.
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   * The date that the user was created.
   * @type {string}
   * @memberof User
   */
  createdAt: string;
  /**
   *
   * @type {Scores}
   * @memberof User
   */
  score: Scores;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Delete logged user. UserId in Auth-Token.
     * @summary Delete User by User ID
     * @param {DeleteUserByIdRequest} [deleteUserByIdRequest] Confirm Deletion with password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserById: async (
      deleteUserByIdRequest?: DeleteUserByIdRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteUserByIdRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get character for classic mode
     * @summary Get Character Info by Id
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterById: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCharacterById', 'id', id);
      const localVarPath = `/characters/{_id}`.replace(
        `{${'_id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all characters to use its name for the Answer-SelectControl-Options
     * @summary Get All Characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacters: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/characters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get logged user. UserId in Auth-Token.
     * @summary Get User By Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all users for Scoreboard
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Login user with email or username.   If successfully logged in, the user receives an access token in return.
     * @summary Login User
     * @param {PostUserLoginRequest} [postUserLoginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserLogin: async (
      postUserLoginRequest?: PostUserLoginRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUserLoginRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new user through Registration
     * @summary Register New User
     * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserRegister: async (
      postUserRegisterRequest?: PostUserRegisterRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUserRegisterRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update score of logged user. UserId in Auth-Token.
     * @summary Update Score by User ID
     * @param {PutScoreByUserIdRequest} [putScoreByUserIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putScoreByUserId: async (
      putScoreByUserIdRequest?: PutScoreByUserIdRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scores`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        putScoreByUserIdRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update logged user. UserId in Auth-Token.
     * @summary Update User by User ID
     * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserById: async (
      putUserByIdRequest?: PutUserByIdRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        putUserByIdRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete logged user. UserId in Auth-Token.
     * @summary Delete User by User ID
     * @param {DeleteUserByIdRequest} [deleteUserByIdRequest] Confirm Deletion with password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserById(
      deleteUserByIdRequest?: DeleteUserByIdRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(
        deleteUserByIdRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.deleteUserById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get character for classic mode
     * @summary Get Character Info by Id
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterById(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Characters>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getCharacterById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all characters to use its name for the Answer-SelectControl-Options
     * @summary Get All Characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacters(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Characters>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacters(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getCharacters']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get logged user. UserId in Auth-Token.
     * @summary Get User By Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserById(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUserById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all users for Scoreboard
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUsers(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUsers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Login user with email or username.   If successfully logged in, the user receives an access token in return.
     * @summary Login User
     * @param {PostUserLoginRequest} [postUserLoginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserLogin(
      postUserLoginRequest?: PostUserLoginRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostUserLogin200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUserLogin(
        postUserLoginRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.postUserLogin']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new user through Registration
     * @summary Register New User
     * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserRegister(
      postUserRegisterRequest?: PostUserRegisterRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostUserRegister201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUserRegister(
          postUserRegisterRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.postUserRegister']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update score of logged user. UserId in Auth-Token.
     * @summary Update Score by User ID
     * @param {PutScoreByUserIdRequest} [putScoreByUserIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putScoreByUserId(
      putScoreByUserIdRequest?: PutScoreByUserIdRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PutScoreByUserId200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putScoreByUserId(
          putScoreByUserIdRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.putScoreByUserId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update logged user. UserId in Auth-Token.
     * @summary Update User by User ID
     * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserById(
      putUserByIdRequest?: PutUserByIdRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserById(
        putUserByIdRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.putUserById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Delete logged user. UserId in Auth-Token.
     * @summary Delete User by User ID
     * @param {DeleteUserByIdRequest} [deleteUserByIdRequest] Confirm Deletion with password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserById(
      deleteUserByIdRequest?: DeleteUserByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserById(deleteUserByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get character for classic mode
     * @summary Get Character Info by Id
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterById(
      id: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Characters> {
      return localVarFp
        .getCharacterById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all characters to use its name for the Answer-SelectControl-Options
     * @summary Get All Characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacters(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Characters>> {
      return localVarFp
        .getCharacters(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get logged user. UserId in Auth-Token.
     * @summary Get User By Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp
        .getUserById(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all users for Scoreboard
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Login user with email or username.   If successfully logged in, the user receives an access token in return.
     * @summary Login User
     * @param {PostUserLoginRequest} [postUserLoginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserLogin(
      postUserLoginRequest?: PostUserLoginRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PostUserLogin200Response> {
      return localVarFp
        .postUserLogin(postUserLoginRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new user through Registration
     * @summary Register New User
     * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserRegister(
      postUserRegisterRequest?: PostUserRegisterRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PostUserRegister201Response> {
      return localVarFp
        .postUserRegister(postUserRegisterRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update score of logged user. UserId in Auth-Token.
     * @summary Update Score by User ID
     * @param {PutScoreByUserIdRequest} [putScoreByUserIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putScoreByUserId(
      putScoreByUserIdRequest?: PutScoreByUserIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PutScoreByUserId200Response> {
      return localVarFp
        .putScoreByUserId(putScoreByUserIdRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update logged user. UserId in Auth-Token.
     * @summary Update User by User ID
     * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserById(
      putUserByIdRequest?: PutUserByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .putUserById(putUserByIdRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Delete logged user. UserId in Auth-Token.
   * @summary Delete User by User ID
   * @param {DeleteUserByIdRequest} [deleteUserByIdRequest] Confirm Deletion with password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteUserById(
    deleteUserByIdRequest?: DeleteUserByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteUserById(deleteUserByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get character for classic mode
   * @summary Get Character Info by Id
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCharacterById(id: number, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getCharacterById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all characters to use its name for the Answer-SelectControl-Options
   * @summary Get All Characters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCharacters(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getCharacters(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get logged user. UserId in Auth-Token.
   * @summary Get User By Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserById(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUserById(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all users for Scoreboard
   * @summary Get All Users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsers(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Login user with email or username.   If successfully logged in, the user receives an access token in return.
   * @summary Login User
   * @param {PostUserLoginRequest} [postUserLoginRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postUserLogin(
    postUserLoginRequest?: PostUserLoginRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .postUserLogin(postUserLoginRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new user through Registration
   * @summary Register New User
   * @param {PostUserRegisterRequest} [postUserRegisterRequest] Necessary fields to create an user:  - username  - email  - password    Everything else get default values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postUserRegister(
    postUserRegisterRequest?: PostUserRegisterRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .postUserRegister(postUserRegisterRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update score of logged user. UserId in Auth-Token.
   * @summary Update Score by User ID
   * @param {PutScoreByUserIdRequest} [putScoreByUserIdRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putScoreByUserId(
    putScoreByUserIdRequest?: PutScoreByUserIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .putScoreByUserId(putScoreByUserIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update logged user. UserId in Auth-Token.
   * @summary Update User by User ID
   * @param {PutUserByIdRequest} [putUserByIdRequest] The user can optionally update their username, email, or password.   We need to ensure that empty input fields are handled properly to prevent the database from being updated with empty values.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putUserById(
    putUserByIdRequest?: PutUserByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .putUserById(putUserByIdRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
